<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Dashboard | SING Cloud | Next-Gen AI Cloud</title>
    
    <!-- Bluma CSS and Bliss JS-->
    <script src="assets/bliss.js"></script>
    <link rel="stylesheet" href="assets/bulma.min.css">

    <!-- TACC Theme files -->
    <link href="assets/tacc-theme.css" rel="stylesheet">
    <script src="assets/tacc-theme.js"></script>
    <script src="scripts/sing-api.js"></script>
    <script type="module" src="./scripts/sing-theme.js"></script>
    
    <!-- Launch page specific styles -->
    <link href="assets/launch-styles.css" rel="stylesheet">
    
    <style>
        /* Shared styles */
        body {
            font-family: "IBM Plex Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            color: #333;
            line-height: 1.5;
        }
        
        /* Resource matching analysis styles */
        .match-status {
            display: inline-flex;
            align-items: center;
            font-weight: 500;
            margin-left: 2px;
            margin-right: 2px;
            padding: 0 3px;
            border-radius: 3px;
            font-size: 0.7rem;
            white-space: nowrap;
            vertical-align: text-top;
            line-height: 1.2;
            position: relative;
            top: -6px;
            right: -1px;
        }

        /* Custom tooltip styles */
        [data-tooltip] {
            position: relative;
            cursor: help;
        }

        [data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(51, 51, 51, 0.95);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 100;
            pointer-events: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
            letter-spacing: 0.2px;
            text-transform: capitalize; /* Ensure first letter capitalization */
            font-family: "IBM Plex Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        [data-tooltip]:hover::after {
            opacity: 1;
            visibility: visible;
        }

        /* Status icon container styles */
        .status-icons-container {
            width: 14px;
            height: 14px;
            display: inline-block;
            position: relative;
            vertical-align: middle;
            margin: 0 2px;
        }

        /* Match status styles */
        .match-status {
            display: none; /* Hidden by default */
            position: absolute;
            left: 0;
            top: 0;
        }

        /* Icon styles */
        .match-status i {
            font-size: 11px;
            line-height: 1;
            text-transform: capitalize;
        }

        /* Icon colors */
        .match-status.good i {
            color: #38a169;
        }

        .match-status.poor i {
            color: #e53e3e;
        }
    </style>
    
    <!-- Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/99d5980073.js" crossorigin="anonymous"></script>

    <!-- Markdown parser -->
    <script src="https://cdn.jsdelivr.net/npm/showdown/dist/showdown.min.js"></script>
</head>
<body>
    <sing-navigation></sing-navigation>
    
    <section class="section form"> 
        <script>
            document.addEventListener('DOMContentLoaded', function(){
                // Initialize Showdown converter with options
                window.converter = new showdown.Converter({
                    ghCompatible: true,
                    simpleLineBreaks: true,
                    sanitize: false,
                    openLinksInNewWindow: true,
                    smartIndentationFix: true
                });
                
                // Get metadata container, ensure it's hidden initially
                const metadataContainer = document.getElementById('image-metadata-container');
                
                if (metadataContainer) {
                    metadataContainer.style.display = 'none';
                } else {
                    console.error("Metadata container not found, please check HTML structure");
                }
                
                // Check metadata content container
                const metadataContent = document.getElementById('image-metadata-content');
                if (!metadataContent) {
                    console.error("Metadata content container not found, please check HTML structure");
                }
                
                let username = 'default';
                
                // Get friendly model name display
                function getDisplayModelName(imageName) {

                    // For other names, perform general formatting
                    return imageName.split('-').map(part => {
                        // Handle number suffixes, like 7b to 7B
                        if (/^\d+[a-z]$/.test(part)) {
                            return part.slice(0, -1) + part.slice(-1).toUpperCase();
                        }
                        // Capitalize first letter
                        return part.charAt(0).toUpperCase() + part.slice(1);
                    }).join('-');
                }
                
                // Add function to display image metadata
                function handleImageChange() {
                    const selectedImage = document.querySelector('select[name="master_image"]').value;
                    const metadataContent = document.getElementById('image-metadata-content');
                    const metadataContainer = document.getElementById('image-metadata-container');
                    const commandInput = document.querySelector('input[name="command"]');
                    const portInput = document.querySelector('.exposed-port'); 
                    const statusIconsContainer = document.getElementById('status-icons-container');
                    
                    const gpuButtons = document.querySelectorAll('.gpu-option.is-selected');
                    gpuButtons.forEach(button => {
                        button.classList.remove('is-primary', 'is-selected');
                    });
                    
                    const nodeOptions = document.querySelectorAll('.gpu-node-option.is-selected');
                    nodeOptions.forEach(button => {
                        button.classList.remove('is-primary', 'is-selected');
                    });
                    
                    document.getElementById('gpu-type-input').value = '';
                    document.getElementById('gpu-name-input').value = '';
                    document.getElementById('num-gpu-per-node-select').value = '1';
                    document.getElementById('num-node-input').value = '1';
                    
                    const gpuNodeSection = document.getElementById('gpu-node-section');
                    if (gpuNodeSection) {
                        gpuNodeSection.style.display = 'none';
                    }
                    
                    const resourcePreview = document.getElementById('resource-allocation-preview');
                    if (resourcePreview) {
                        resourcePreview.style.display = 'none';
                    }
                    
                    const matchStatusGoodElement = document.getElementById('match-status-good');
                    const matchStatusPoorElement = document.getElementById('match-status-poor');
                    if(matchStatusGoodElement) matchStatusGoodElement.style.display = 'none';
                    if(matchStatusPoorElement) matchStatusPoorElement.style.display = 'none';
                    if(statusIconsContainer) statusIconsContainer.style.display = 'none';
                    
                    const nodeOptionsContainer = document.getElementById('gpu-node-options');
                    if (nodeOptionsContainer) {
                        nodeOptionsContainer.innerHTML = '';
                    }
                    
                    // If no image is selected, hide all content and return
                    if (!selectedImage) {
                        if (metadataContent) metadataContent.innerHTML = '';
                        if (metadataContainer) metadataContainer.style.display = 'none';
                        if (commandInput) commandInput.value = '';
                        if (portInput) portInput.value = ''; 
                        
                        return;
                    }
                    
                    // Find the selected image from all image data
                    const selectedImageObj = window.imagesData.images.find(img => img.full_name === selectedImage);
                    
                    // If the image is not found, hide all content
                    if (!selectedImageObj) {
                        if (metadataContainer) metadataContainer.style.display = 'none';
                        if (commandInput) commandInput.value = '';
                        if (portInput) portInput.value = ''; 
                        
                        // Hide resource matching status icons
                        const matchStatusGoodElement = document.getElementById('match-status-good');
                        const matchStatusPoorElement = document.getElementById('match-status-poor');
                        if(matchStatusGoodElement) matchStatusGoodElement.style.display = 'none';
                        if(matchStatusPoorElement) matchStatusPoorElement.style.display = 'none';
                        if(statusIconsContainer) statusIconsContainer.style.display = 'none';
                        
                        return;
                    }
                    
                    // Found the image, process image information
                    // Image name display style
                    const displayName = getDisplayModelName(selectedImageObj.name);
                    
                    // Set default entrypoint (if exists)
                    if (commandInput) {
                        if (selectedImageObj.default_entrypoint) {
                            commandInput.value = selectedImageObj.default_entrypoint;
                        } else {
                            commandInput.value = '';
                        }
                    }
                    
                    // Set default port (if exists)
                    if (portInput && selectedImageObj.default_port) {
                        portInput.value = selectedImageObj.default_port;
                    } else if (portInput) {
                        portInput.value = '';
                    }
                    
                    // Set default environment variables
                    if (selectedImageObj.default_env_vars && Array.isArray(selectedImageObj.default_env_vars) && selectedImageObj.default_env_vars.length > 0) {
                        const envVarContainer = document.querySelector('.env-var-container');
                        while (envVarContainer.children.length > 1) {
                            envVarContainer.removeChild(envVarContainer.lastChild);
                        }
                        
                        // Set first env var
                        const firstEnvVar = selectedImageObj.default_env_vars[0];
                        const firstEnvVarEl = envVarContainer.querySelector('.env-var');
                        const nameInput = firstEnvVarEl.querySelector('input[name="env_name"]');
                        const valueInput = firstEnvVarEl.querySelector('input[name="env_value"]');
                        
                        if (nameInput && valueInput) {
                            nameInput.value = firstEnvVar.name || '';
                            valueInput.value = firstEnvVar.value || '';
                        }
                        
                        // Add remaining env vars
                        for (let i = 1; i < selectedImageObj.default_env_vars.length; i++) {
                            const envVar = selectedImageObj.default_env_vars[i];
                            const newRow = document.createElement('div');
                            newRow.classList.add('field', 'is-grouped', 'env-var');
                            newRow.innerHTML = `
                                <div class="control is-expanded">
                                    <input class="input" type="text" name="env_name" placeholder="Variable name" value="${envVar.name || ''}">
                                </div>
                                <div class="control is-expanded">
                                    <input class="input" type="text" name="env_value" placeholder="Value" value="${envVar.value || ''}">
                                </div>
                                <div class="control">
                                    <button class="button is-danger remove_env_var"> × </button>
                                </div>
                            `;
                            envVarContainer.appendChild(newRow);
                            
                            // Add event listener for remove button
                            const removeBtn = newRow.querySelector('.remove_env_var');
                            if (removeBtn) {
                                removeBtn.addEventListener('click', function() {
                                    envVarContainer.removeChild(newRow);
                                });
                            }
                        }
                    } else {
                        // Clear all env var inputs
                        const envVarInputs = document.querySelectorAll('.env-var input');
                        envVarInputs.forEach(input => {
                            input.value = '';
                        });
                    }
                    
                    // Build metadata HTML
                    let metadataHTML = `<div class="metadata-title">
                        ${displayName}
                        ${selectedImageObj.github_repo ? 
                            `<a href="${selectedImageObj.github_repo}" target="_blank" class="metadata-repo-link">
                                <i class="fa-brands fa-github"></i>
                            </a>` : 
                            ''}
                    </div>`;
                    
                    // Add description with Markdown support (if exists)
                    if (selectedImageObj.description) {
                        const descriptionHtml = window.converter.makeHtml(selectedImageObj.description);
                        metadataHTML += `
                        <div class="metadata-item">
                            <div class="metadata-content">${descriptionHtml}</div>
                        </div>`;
                    }
                    
                    // Update metadata content and display
                    metadataContent.innerHTML = metadataHTML;
                    metadataContainer.style.display = 'block';
                    
                    // Get current selected GPU information
                    const gpuTypeInput = document.getElementById('gpu-type-input');
                    const gpuLimitInput = document.getElementById('gpu-limit-input');
                    const gpuType = gpuTypeInput ? gpuTypeInput.value : '';
                    const gpuCount = gpuLimitInput ? parseInt(gpuLimitInput.value) || 1 : 1;

                    // Show resource allocation preview
                    const previewContainer = document.getElementById('resource-allocation-preview');
                    if (previewContainer) {
                        previewContainer.style.display = 'block';
                    }

                    // Check resource matching status
                    // Check if the image has a valid minimum_gpu_memory property
                    if (selectedImageObj.minimum_gpu_memory && selectedImageObj.minimum_gpu_memory.toString().trim() !== '') {
                        // Show matching status icons
                        if (statusIconsContainer) {
                            statusIconsContainer.style.display = 'inline-block';
                        }
                        // Update resource allocation preview
                        updateResourceAllocationPreview(selectedImageObj, gpuType, gpuCount);
                    } else {
                        // If the image does not have a valid minimum_gpu_memory property, hide matching status
                        const matchStatusGoodElement = document.getElementById('match-status-good');
                        const matchStatusPoorElement = document.getElementById('match-status-poor');

                        if (matchStatusGoodElement) matchStatusGoodElement.style.display = 'none';
                        if (matchStatusPoorElement) matchStatusPoorElement.style.display = 'none';
                        if (statusIconsContainer) statusIconsContainer.style.display = 'none';
                    }
                }

                
                // Process URL parameters to prefill image name, entrypoint and ports
                function processUrlParameters() {
                    const urlParams = new URLSearchParams(window.location.search);
                    const repository = urlParams.get('repository');
                    const imageName = urlParams.get('image');
                    const tag = urlParams.get('tag');
                    const entrypoint = urlParams.get('entrypoint');
                    const ports = urlParams.get('ports');
                    
                    if (repository && imageName && tag) {
                        const fullImageName = `${repository}/${imageName}:${tag}`;
                        
                        // Pre-fill image name
                        window.selectedImageFromUrl = fullImageName;
                        // Pre-fill entrypoint
                        if (entrypoint) {
                            document.querySelector('input[name="command"]').value = entrypoint;
                        }
                        // Pre-fill ports
                        if (ports) {
                            try {
                                const portsObj = JSON.parse(ports);
                                // Format ports for the input field (comma-separated)
                                if (typeof portsObj === 'object') {
                                    const portsList = Object.keys(portsObj).join(',');
                                    document.querySelector('.exposed-port').value = portsList;
                                }
                            } catch (e) {
                                console.error("Error parsing ports JSON:", e);
                            }
                        }
                    }
                }
                
                function fetchUserInfo() {
                    api.get('/me')
                        .then(data => {
                            if (data && data.username) {
                                username = data.username;
                                document.querySelector('input[name="namespace"]').value = username;
                            }
                        })
                        .catch(error => {
                            console.error("Failed to fetch user info:", error);
                        });
                }
                
                // Fetch images from API and populate select box
                function fetchImages() {
                    api.get(`/me/images`)
                        .then(data => {
                            // Save all image data for later use
                            window.imagesData = data;
                            
                            // Enhance images with metadata
                            enhanceImagesWithMetadata(data.images);
                            
                            var select = document.querySelector('select[name="master_image"]');
                            select.innerHTML = "";
                            
                            data.images.forEach(image => {
                                var option = document.createElement('option');
                                option.value = image.full_name;
                                option.textContent = image.full_name; // Restore original display, show full image name
                                select.appendChild(option);
                            });
                            
                            // Check if image is pre-selected
                            if (window.selectedImageFromUrl) {
                                // Find with matching value
                                const options = select.options;
                                for (let i = 0; i < options.length; i++) {
                                    if (options[i].value === window.selectedImageFromUrl) {
                                        select.selectedIndex = i;
                                        break;
                                    }
                                }
                            }
                            
                            if (!select.value && select.options.length > 0) {
                                select.selectedIndex = 0;
                            }
                            
                            // Add event listener
                            select.addEventListener('change', handleImageChange);
                            
                            // Immediately trigger selection event to display metadata
                            handleImageChange();
                        })
                        .catch(error => {
                            console.error("Failed to fetch images:", error);
                        });
                }
                
                // No longer need to enhance image metadata, use data directly from backend API
                function enhanceImagesWithMetadata(images) {
                    // Function kept for compatibility
                }


                // Add function to display regions
                function populateRegions() {
                    const regionContainer = document.getElementById('region-options-container');
                    
                    // Clear existing content
                    regionContainer.innerHTML = '';
                    
                    // Check if window.allRegions exists
                    if (window.allRegions) {
                        // Create buttons for each region
                        for (const regionCode in window.allRegions) {
                            const regionName = window.allRegions[regionCode];
                            
                            const regionButton = document.createElement('button');
                            regionButton.classList.add('button', 'region-option', 'is-primary', 'is-selected', 'mr-2', 'mb-2');
                            regionButton.dataset.region = regionCode;
                            regionButton.textContent = regionName;
                            // Set fixed width and height for consistent button size
                            regionButton.style.width = '150px';
                            regionButton.style.height = '40px';
                            
                            regionButton.addEventListener('click', function() {
                                // Toggle selection
                                this.classList.toggle('is-primary');
                                this.classList.toggle('is-selected');
                                
                                // Update hidden input with all selected regions
                                updateSelectedRegions();
                            });
                            
                            regionContainer.appendChild(regionButton);
                        }
                        
                        // Update hidden input with all selected regions initially
                        updateSelectedRegions();
                    }
                }
                
                // Function to update selected regions
                function updateSelectedRegions() {
                    const selectedButtons = document.querySelectorAll('.region-option.is-selected');
                    const selectedRegions = Array.from(selectedButtons).map(button => button.dataset.region);
                    document.getElementById('selected-region-input').value = JSON.stringify(selectedRegions);

                    // Show GPU type selection if at least one region is selected
                    if (selectedRegions.length > 0) {
                        document.getElementById('gpu-type-selection').style.display = 'block';
                        renderGPUTypeSelection();
                    } else {
                        document.getElementById('gpu-type-selection').style.display = 'none';
                    }
                }
                

                // Fetch available GPU information
                function fetchGpuInfo() {
                    api.get(`/gpu-info`)
                    .then(data => {
                        window.gpuInfo = data.gpu_info || {};

                        const regionDict = {};
                        if (window.gpuInfo) {
                            for (const nodeKey in window.gpuInfo) {
                                const node = window.gpuInfo[nodeKey];
                                if (node.region && node.region_name) {
                                    regionDict[node.region] = node.region_name;
                                }
                            }
                        }
                        window.allRegions = regionDict;
                    })
                    .catch(error => {
                        console.error("Failed to fetch GPU info:", error);
                    });
                }


                function renderGPUTypeSelection() {
                    const gpuContainer = document.getElementById('gpu-options-container');
                    gpuContainer.innerHTML = '';

                    // Get the selected regions
                    
                    // Get the selected regions
                    const selectedRegions = JSON.parse(document.getElementById('selected-region-input').value || '[]');
                    if (!selectedRegions.length) {
                        return; // If no regions selected, don't display GPU options
                    }

                    // Create container for GPU buttons
                    gpuContainer.classList.add('is-flex', 'is-flex-wrap-wrap');

                    // Filter GPU types based on selected regions
                    // Create dictionary to store nodes by GPU type
                    const filteredGpuTypes = {};
                    
                    // Iterate through all GPU nodes
                    for (const nodeKey in window.gpuInfo) {
                        const node = window.gpuInfo[nodeKey];

                        // Always add this GPU type to the dictionary no matter it is selected or not
                        // If this GPU type doesn't exist in our dictionary yet, create an array for it
                        if (!filteredGpuTypes[node.gpu_sku]) {
                            filteredGpuTypes[node.gpu_sku] = {
                                nodes: [],
                                gpu_name: node.gpu_name,
                                gpu_memory_gb: node.gpu_memory_gb,
                                total: 0,
                                used: 0
                            };
                        }
                        
                        // Check if node's region is in selected regions
                        if (selectedRegions.includes(node.region)) {
                            // Add this node to the array for this GPU type
                            filteredGpuTypes[node.gpu_sku].nodes.push(node);
                            
                            // Update totals
                            filteredGpuTypes[node.gpu_sku].total += (node.total || 0);
                            filteredGpuTypes[node.gpu_sku].used += (node.used || 0);
                        }
                    }

                    // Create buttons for each GPU type
                    for (const gpuType in filteredGpuTypes) {
                        const gpuButton = document.createElement('button');
                        gpuButton.classList.add('button', 'gpu-option', 'mr-2', 'mb-2');
                        gpuButton.dataset.type = gpuType;
                        gpuButton.dataset.name = filteredGpuTypes[gpuType].gpu_name || gpuType;
                        gpuButton.dataset.total = filteredGpuTypes[gpuType].total || 0;
                        gpuButton.dataset.used = filteredGpuTypes[gpuType].used || 0;
                        const available = Math.max(0, (filteredGpuTypes[gpuType].total || 0) - (filteredGpuTypes[gpuType].used || 0));
                        gpuButton.textContent = `${filteredGpuTypes[gpuType].gpu_name || gpuType} (${available})`;
                        // Set fixed width and height for consistent button size - same as region buttons
                        gpuButton.style.width = '150px';
                        gpuButton.style.height = '40px';
                        
                        // Add click event listener
                        gpuButton.addEventListener('click', function() {
                            this.classList.toggle('is-primary');
                            this.classList.toggle('is-selected');
                            
                            // Update hidden inputs with selected GPU types
                            updateSelectedGpuTypes();
                            
                            // Setup GPU-node options based on selected GPU types
                            setupGpuNodeOptionsForMulti();
                        });
                        
                        gpuContainer.appendChild(gpuButton);
                    }

                    // if gpuContainer is empty, hide the section
                    if (gpuContainer.children.length == 0) {
                        gpuContainer.style.display = 'none';
                    } else {
                        gpuContainer.style.display = 'block';
                    }
                }

                
                // Initialize environment variable functionality
                document.getElementById('add_env_var').addEventListener('click', function() {
                    var envVarContainer = document.querySelector('.env-var-container');
                    var newEnvVar = document.createElement('div');
                    newEnvVar.classList.add('field', 'is-grouped', 'env-var');
                    newEnvVar.innerHTML = `
                        <div class="control is-expanded">
                            <input class="input" type="text" name="env_name" placeholder="Variable name">
                        </div>
                        <div class="control is-expanded">
                            <input class="input" type="text" name="env_value" placeholder="Value">
                        </div>
                        <div class="control">
                            <button class="button is-danger remove_env_var"> × </button>
                        </div>
                    `;
                    envVarContainer.append(newEnvVar);
                    newEnvVar.querySelector('.remove_env_var').addEventListener('click', function() {
                        envVarContainer.removeChild(newEnvVar);
                    });
                });
                
                // Form submission
                document.getElementById('submit').addEventListener('click', function(){
                    const commandValue = document.querySelector('input[name="command"]').value.trim();

                    const selectedRegions = JSON.parse(document.getElementById('selected-region-input').value || '[]');
                    if (!selectedRegions.length) {
                        showResultModal('Warning', 'Please select at least one region', 'is-warning');
                        return;
                    }
                    
                    const selectedGpuTypes = JSON.parse(document.getElementById('gpu-type-input').value || '[]');
                    if (!selectedGpuTypes.length) {
                        showResultModal('Warning', 'Please select at least one GPU type', 'is-warning');
                        return;
                    }
                    
                    // Check if GPU node section exists and is visible
                    const gpuNodeSection = document.getElementById('gpu-node-section');
                    if (gpuNodeSection && gpuNodeSection.style.display !== 'none') {
                        // Only validate selection if the section is visible
                        const numGpuPerNode = parseInt(document.getElementById('num-gpu-per-node-select').value) || 0;
                        const numNode = parseInt(document.getElementById('num-node-input').value) || 0;
                        
                        if (numGpuPerNode < 0 || numNode <= 0) {
                            showResultModal('Warning', 'Please configure GPU node settings properly', 'is-warning');
                            return;
                        }
                    }
                    
                    const useSSH = true;
                    const portsInput = document.querySelector('.exposed-port').value.trim();
                    const exposedPorts = portsInput ? 
                        portsInput.split(',').map(port => parseInt(port.trim())).filter(port => !isNaN(port)) : 
                        [];
                    
                    var data = {
                        namespace: document.querySelector('input[name="namespace"]').value || username,
                        job_name: document.querySelector('input[name="job_name"]').value || 'job',
                        master_image: document.querySelector('select[name="master_image"]').value,
                        num_node: parseInt(document.getElementById('num-node-input').value) || 0,
                        cpu_limit: 2,
                        memory_limit: '10Gi',
                        num_gpu_per_node: parseInt(document.getElementById('num-gpu-per-node-select').value) || 0,
                        commandArray: commandValue ? commandValue.split(/\s+/).map(arg => arg.trim()) : [],
                        env_vars: [],
                        use_ssh: useSSH,
                        gpu_type: selectedGpuTypes,
                        exposed_ports: exposedPorts,
                        regions: selectedRegions,
                    };
                    
                    document.querySelectorAll('.env-var').forEach(function(row) {
                        const name = row.querySelector('input[name="env_name"]').value;
                        const value = row.querySelector('input[name="env_value"]').value;
                        if (name) {
                            data.env_vars.push({
                                name: name,
                                value: value
                            });
                        }
                    });
                    
                    // Create confirm dialog content
                    let confirmContent = `
                    <div class="modal is-active">
                        <div class="modal-background"></div>
                        <div class="modal-card">
                            <header class="modal-card-head">
                                <p class="modal-card-title">Confirm Job Creation</p>
                                <button class="delete close-modal" aria-label="close"></button>
                            </header>
                            <section class="modal-card-body">
                                <div class="content">
                                    <h4>Job Configuration</h4>
                                    <table class="table is-fullwidth">
                                        <tbody>
                                            <tr><td>Namespace:</td><td>${data.namespace}</td></tr>
                                            <tr><td>Job Name:</td><td>${data.job_name}</td></tr>
                                            <tr><td>Image:</td><td>${data.master_image}</td></tr>
                                            <tr><td>GPU Type:</td><td>${document.getElementById('gpu-name-input').value}</td></tr>
                                            <tr><td>Region:</td><td>${data.regions.map(regionCode => window.allRegions[regionCode] || regionCode).join(', ')}</td></tr>
                                            <tr><td>GPU Count:</td><td>${data.num_gpu_per_node}</td></tr>
                                            <tr><td>node Count:</td><td>${data.num_node}</td></tr>
                                            <tr><td>CPU Limit:</td><td>${data.cpu_limit} cores</td></tr>
                                            <tr><td>Memory Limit:</td><td>${data.memory_limit}</td></tr>
                                            <tr><td>Command:</td><td>${data.commandArray.length > 0 ? data.commandArray.join(' ') : 'None (SSH mode)'}</td></tr>
                                            <tr><td>SSH Mode:</td><td>${data.use_ssh ? 'Enabled' : 'Disabled'}</td></tr>
                                            <tr><td>Exposed Ports:</td><td>${data.exposed_ports.length > 0 ? data.exposed_ports.join(', ') : 'None'}</td></tr>
                                        </tbody>
                                    </table>
                                    ${data.env_vars.length > 0 ? `
                                    <h4>Environment Variables</h4>
                                    <table class="table is-fullwidth">
                                        <thead>
                                            <tr><th>Name</th><th>Value</th></tr>
                                        </thead>
                                        <tbody>
                                            ${data.env_vars.map(env => `<tr><td>${env.name}</td><td>${env.value}</td></tr>`).join('')}
                                        </tbody>
                                    </table>
                                    ` : ''}
                                </div>
                            </section>
                            <footer class="modal-card-foot">
                                <button class="button is-primary confirm-create">Confirm</button>
                                <button class="button close-modal">Cancel</button>
                            </footer>
                        </div>
                    </div>
                    `;
                    
                    // Add confirm dialog to page
                    const confirmModal = document.createElement('div');
                    confirmModal.innerHTML = confirmContent;
                    document.body.appendChild(confirmModal);
                    
                    // Handle close button
                    document.querySelectorAll('.close-modal').forEach(btn => {
                        btn.addEventListener('click', function() {
                            document.body.removeChild(confirmModal);
                        });
                    });
                    
                    // Handle confirm button
                    document.querySelector('.confirm-create').addEventListener('click', function() {
                        // Remove confirm dialog
                        document.body.removeChild(confirmModal);

                        console.log('Creating job with data:', data);
                        
                        // Send API request to create job
                        api.post(`/me/create-job-multi`, data)
                            .then(result => {
                                showResultModal('Success', 'Job created successfully!', 'is-success', function() {
                                    window.location.href = '/';
                                });
                            })
                            .catch(error => {
                                console.error('Error creating job:', error);
                                
                                let errorMessage = 'Failed to create job';
                                let errorDetails = '';
                                
                                if (error.message) {
                                    errorMessage = error.message;
                                }
                                
                                if (error.details) {
                                    if (typeof error.details === 'string') {
                                        try {
                                            const detailsObj = JSON.parse(error.details);
                                            
                                            if (detailsObj.message) {
                                                errorDetails = detailsObj.message;
                                            } else if (detailsObj.details && detailsObj.details.causes) {
                                                const causes = detailsObj.details.causes;
                                                if (causes && causes.length > 0) {
                                                    errorDetails = causes.map(cause => 
                                                        `${cause.field}: ${cause.message}`).join('\n');
                                                }
                                            }
                                        } catch (e) {
                                            errorDetails = error.details;
                                        }
                                    } else if (typeof error.details === 'object') {
                                        if (error.details.message) {
                                            errorDetails = error.details.message;
                                        }
                                    }
                                }
                                
                                if (!errorDetails && error.response) {
                                    try {
                                        const responseData = JSON.parse(error.response);
                                        if (responseData.message) {
                                            if (errorMessage === 'Failed to create job') {
                                                errorMessage = responseData.message;
                                            } else {
                                                errorDetails = responseData.message;
                                            }
                                        }
                                    } catch (e) {
                                        errorDetails = error.response;
                                    }
                                }
                                
                                let fullErrorMessage = errorMessage;
                                if (errorDetails && !errorMessage.includes(errorDetails)) {
                                    fullErrorMessage += `\n\n${errorDetails}`;
                                }
                                
                                showResultModal('Error', fullErrorMessage, 'is-danger');
                            });
                    });
                });
                
                // Initialize page
                // Change: Load GPU information first, then load image information
                fetchGpuInfo(); 
                fetchUserInfo();
                fetchImages();
                processUrlParameters();

                // Check if gpuInfo is already loaded
                if (window.gpuInfo) {
                    populateRegions();
                } else {
                    // Wait for GPU info to be loaded
                    const checkGpuInfoInterval = setInterval(function() {
                        if (window.allRegions) {
                            clearInterval(checkGpuInfoInterval);
                            populateRegions();
                        }
                    }, 500);
                }
            }); // DOMContentLoaded end!!!


            // Check resource matching status
            function updateResourceMatchingStatus(selectedImageObj) {
                // Get match status elements
                const matchStatusGoodElement = document.getElementById('match-status-good');
                const matchStatusPoorElement = document.getElementById('match-status-poor');
                const statusIconsContainer = document.getElementById('status-icons-container');
                
                // Hide match status by default
                if(matchStatusGoodElement) matchStatusGoodElement.style.display = 'none';
                if(matchStatusPoorElement) matchStatusPoorElement.style.display = 'none';

                // Check if the image has a valid minimum_gpu_memory property
                if(!selectedImageObj || !selectedImageObj.minimum_gpu_memory || selectedImageObj.minimum_gpu_memory.toString().trim() === ''){
                    // Hide matching status icons
                    if(statusIconsContainer){
                        statusIconsContainer.style.display = 'none';
                    }
                    return;
                }

                // Show matching status icons   
                if(statusIconsContainer){
                    statusIconsContainer.style.display = 'inline-block';
                }

                // Get image's minimum GPU memory requirement by the image
                let minimumGpuMemory = 0;
                if(selectedImageObj.minimum_gpu_memory){
                    if(!isNaN(selectedImageObj.minimum_gpu_memory)){
                        minimumGpuMemory = parseInt(selectedImageObj.minimum_gpu_memory);
                    } else if(typeof selectedImageObj.minimum_gpu_memory === 'string'){
                        const memoryMatch = selectedImageObj.minimum_gpu_memory.match(/(\d+)/);
                        if(memoryMatch){
                            minimumGpuMemory = parseInt(memoryMatch[1]);
                        }
                    }
                }

                // Since we're not checking GPU type and count, we'll just show the requirements
                if(minimumGpuMemory > 0){
                    // Show the minimum requirements without comparing to selected resources
                    if(matchStatusGoodElement) matchStatusGoodElement.style.display = 'inline-flex';
                }   
            }


            // Function to update hidden inputs with selected GPU types
            function updateSelectedGpuTypes() {
                const selectedButtons = document.querySelectorAll('.gpu-option.is-selected');
                const selectedTypes = Array.from(selectedButtons).map(button => button.dataset.type);
                const selectedNames = Array.from(selectedButtons).map(button => button.dataset.name);
                
                document.getElementById('gpu-type-input').value = JSON.stringify(selectedTypes);
                document.getElementById('gpu-name-input').value = selectedNames.join(', ');
                
                const gpuNodeSection = document.getElementById('gpu-node-section');
                if (selectedButtons.length > 0) {
                    gpuNodeSection.style.display = 'block';
                } else {
                    gpuNodeSection.style.display = 'none';
                }
                updateNodeMaxCount();
                updateConfiguration();
            }


            // Function to setup GPU-node options based on selected GPU types
            function setupGpuNodeOptionsForMulti() {
                const selectedButtons = document.querySelectorAll('.gpu-option.is-selected');
                const selectedTypes = Array.from(selectedButtons).map(button => button.dataset.type);
                
                // Hide GPU node section if no GPUs are selected
                if (selectedButtons.length === 0) {
                    const container = document.getElementById('gpu-node-section');
                    document.getElementById('resource-allocation-preview').style.display = 'none';
                    container.style.display = 'none';
                    return;
                }
                
                // Show GPU node section when GPUs are selected
                document.getElementById('gpu-node-section').style.display = 'block';
                
                // Initialize variables for GPU availability tracking
                let totalAvailableGPUs = 0;
                let maxGpusPerNode = 0;
                let minGpusPerNode = Infinity;
                let hasEnabledOption = false;
                
                // Calculate available GPUs from GPU info
                if(window.gpuInfo) {
                    for (const nodeKey in window.gpuInfo) {
                        const node = window.gpuInfo[nodeKey];
                        if (selectedTypes.includes(node.gpu_sku)) {
                            const nodeAvailableGPUs = Math.max(0, (node.total || 0) - (node.used || 0));
                            maxGpusPerNode = Math.max(maxGpusPerNode, nodeAvailableGPUs);
                            minGpusPerNode = Math.min(minGpusPerNode, nodeAvailableGPUs);
                        }
                    }
                }

                // Handle case where no GPUs are available
                if (minGpusPerNode === Infinity) {
                    minGpusPerNode = 0;
                }

                // Calculate total available GPUs across all selected types
                selectedButtons.forEach((button, index) => {
                    const totalGPUs = parseInt(button.dataset.total) || 0;
                    const usedGPUs = parseInt(button.dataset.used) || 0;
                    const availableGPUs = Math.max(0, totalGPUs - usedGPUs);
                    
                    totalAvailableGPUs += availableGPUs;
                });
                
                // Get references to form elements
                const gpuSelectElement = document.getElementById('num-gpu-per-node-select');
                const nodeInput = document.getElementById('num-node-input');
                
                // Set up event listeners for GPU and node inputs
                gpuSelectElement.addEventListener('change', function() {
                    // Reset node input when GPU selection changes
                    nodeInput.value = 1;
                    updateConfiguration();
                });
                
                nodeInput.addEventListener('input', updateConfiguration);
                
                // Initialize configuration if GPUs are available
                if (totalAvailableGPUs > 0) {
                    hasEnabledOption = true;
                    updateConfiguration();
                    
                    // Update resource matching status based on selected image
                    const selectedImage = document.querySelector('select[name="master_image"]').value;
                    if (selectedImage) {
                        const selectedImageObj = window.imagesData.images.find(img => img.full_name === selectedImage);
                        if (selectedImageObj) {
                            updateResourceMatchingStatus(selectedImageObj, parseInt(gpuSelectElement.value));
                        }
                    }
                }
                
                // Reset resource preview and status indicators
                document.getElementById('resource-allocation-preview').style.display = 'none';
                document.getElementById('match-status-good').style.display = 'none';
                document.getElementById('match-status-poor').style.display = 'none';
                
                // Select first available option if any are enabled
                if (hasEnabledOption) {
                    const container = document.getElementById('gpu-node-section');
                    if (container) {
                        for (let i = 0; i < container.children.length; i++) {
                            const button = container.children[i];
                            if (!button.disabled) {
                                button.click();
                                break;
                            }
                        }
                        
                        // Update resource matching status for selected image
                        const selectedImage = document.querySelector('select[name="master_image"]').value;
                        if (selectedImage) {
                            const selectedImageObj = window.imagesData.images.find(img => img.full_name === selectedImage);
                            if (selectedImageObj) {
                                const firstEnabledOption = Array.from(container.children).find(btn => !btn.disabled);
                                const gpuCount = firstEnabledOption ? parseInt(firstEnabledOption.dataset.gpus) || 1 : 1;
                                updateResourceMatchingStatus(selectedImageObj, gpuCount);
                            }
                        }
                    }
                }
            }

            function calculateMaxNodes() {
                const gpuSelectElement = document.getElementById('num-gpu-per-node-select');
                const gpusPerNode = parseInt(gpuSelectElement.value);
                
                // Calculate total available GPUs from selected options
                const selectedButtons = document.querySelectorAll('.gpu-option.is-selected');
                let totalAvailableGPUs = 0;
                
                selectedButtons.forEach((button) => {
                    const totalGPUs = parseInt(button.dataset.total) || 0;
                    const usedGPUs = parseInt(button.dataset.used) || 0;
                    const availableGPUs = Math.max(0, totalGPUs - usedGPUs);
                    totalAvailableGPUs += availableGPUs;
                });
                
                // Calculate maximum possible nodes based on available GPUs
                return gpusPerNode > 0 ? Math.floor(totalAvailableGPUs / gpusPerNode) : 10;
            }

            function updateNodeMaxCount() {
                // console.log('updateNodeMaxCount is called');
                const nodeInput = document.getElementById('num-node-input');
                const maxNodes = calculateMaxNodes();
                
                // Update the max attribute of the input element
                nodeInput.setAttribute('max', maxNodes);
                
                // Adjust node count if it exceeds the new maximum
                if (parseInt(nodeInput.value) > maxNodes) {
                    nodeInput.value = maxNodes;
                }
                
                // Validate the input
                validateNodeInput(nodeInput);
            }

            function validateNodeInput(input) {
                // console.log('validateNodeInput is called');
                const value = parseInt(input.value);
                const max = parseInt(input.getAttribute('max'));
                const min = parseInt(input.getAttribute('min'));
                const gpuLimitWarning = document.getElementById('gpu-limit-warning');
                const nodeLimitWarning = document.getElementById('node-limit-warning');
                
                // Hide all warnings by default
                gpuLimitWarning.style.display = 'none';
                nodeLimitWarning.style.display = 'none';
                
                // Validate input value against min/max constraints
                if (isNaN(value) || value < min) {
                    input.value = min;
                    nodeLimitWarning.style.display = 'block';
                } else if (value > max) {
                    input.value = max;
                    gpuLimitWarning.style.display = 'block';
                }
                
                // Update configuration based on new input
                updateConfiguration();
            }

            function updateConfiguration() {
                const gpuSelectElement = document.getElementById('num-gpu-per-node-select');
                const nodeInput = document.getElementById('num-node-input');
                const gpuLimitWarning = document.getElementById('gpu-limit-warning');
                const nodeLimitWarning = document.getElementById('node-limit-warning');
                
                const gpusPerNode = parseInt(gpuSelectElement.value);
                let nodeCount = parseInt(nodeInput.value);
                
                // Get maximum possible nodes
                const maxNodes = calculateMaxNodes();
                
                // Hide warnings by default
                gpuLimitWarning.style.display = 'none';
                nodeLimitWarning.style.display = 'none';
                
                // Validate node count and show appropriate warnings
                if (isNaN(nodeCount) || nodeCount < 1) {
                    nodeCount = 1;
                    nodeInput.value = 1;
                    nodeLimitWarning.style.display = 'block';
                } else if (nodeCount > maxNodes) {
                    nodeCount = maxNodes;
                    nodeInput.value = maxNodes;
                    gpuLimitWarning.style.display = 'block';
                }
                
                // Update hidden form fields with current configuration
                const hiddenGpuInput = document.getElementById('num-gpu-per-node-select');
                if (hiddenGpuInput) {
                    hiddenGpuInput.value = gpusPerNode;
                }
                
                // No need to update nodeInput again as we already set it above
                
                // Update the resource allocation preview
                updateResourceAllocationPreview(gpusPerNode, nodeCount);
            }
            

            // Function to update the resource allocation preview
            function updateResourceAllocationPreview(gpuCount, nodeCount) {
                const previewContainer = document.getElementById('resource-allocation-preview');
                
                // Get selected GPU information
                let cpuCoresPerGpu = 0;
                let memoryGbPerGpu = 0;
                
                // Calculate total resources
                const totalCpuCores = (cpuCoresPerGpu * gpuCount * nodeCount).toFixed(1);
                const totalMemoryGb = (memoryGbPerGpu * gpuCount * nodeCount).toFixed(1);
                
                // Update preview information
                const gpuValueText = `${gpuCount} GPUs × ${nodeCount} Nodes`;
                
                document.getElementById('preview-gpu-info').textContent = gpuValueText;
                document.getElementById('preview-cpu-info').textContent = `${totalCpuCores} cores (automatically assigned)`;
                document.getElementById('preview-memory-info').textContent = `${totalMemoryGb}Gi (automatically assigned)`;
                
                // Show preview container
                previewContainer.style.display = 'block';
                
                // Get current selected image
                const selectedImage = document.querySelector('select[name="master_image"]').value;
                
                // Get match status elements
                const matchStatusGoodElement = document.getElementById('match-status-good');
                const matchStatusPoorElement = document.getElementById('match-status-poor');
                
                // Hide match status by default
                matchStatusGoodElement.style.display = 'none';
                matchStatusPoorElement.style.display = 'none';
                
                // If no image selected, don't perform resource matching analysis
                if (!selectedImage) {
                    return;
                }
                
                // Find selected image metadata
                const selectedImageData = window.imagesData && window.imagesData.images ? 
                    window.imagesData.images.find(img => img.full_name === selectedImage) : null;
                
                // If the image does not have the minimum_gpu_memory property, hide matching status
                if (!selectedImageData || !selectedImageData.minimum_gpu_memory || selectedImageData.minimum_gpu_memory.toString().trim() === '') {
                    matchStatusGoodElement.style.display = 'none';
                    matchStatusPoorElement.style.display = 'none';

                    const statusIconsContainer = document.getElementById('status-icons-container');
                    if(statusIconsContainer) statusIconsContainer.style.display = 'none';
                    
                    return;
                }else{
                    // Show matching status icons
                    const statusIconsContainer = document.getElementById('status-icons-container');
                    if(statusIconsContainer) statusIconsContainer.style.display = 'inline-block';
                }
            }




            // Add a generic result display modal function
            function showResultModal(title, message, colorClass, callback) {
                const resultModalContent = `
                <div class="modal is-active">
                    <div class="modal-background"></div>
                    <div class="modal-card">
                        <header class="modal-card-head ${colorClass}">
                            <p class="modal-card-title">${title}</p>
                            <button class="delete close-result-modal" aria-label="close"></button>
                        </header>
                        <section class="modal-card-body">
                            <div class="content">
                                <p>${message}</p>
                            </div>
                        </section>
                        <footer class="modal-card-foot">
                            <button class="button ${colorClass} close-result-modal">OK</button>
                        </footer>
                    </div>
                </div>
                `;
                
                const resultModal = document.createElement('div');
                resultModal.innerHTML = resultModalContent;
                document.body.appendChild(resultModal);
                
                // Handle close button
                document.querySelectorAll('.close-result-modal').forEach(btn => {
                    btn.addEventListener('click', function() {
                        document.body.removeChild(resultModal);
                        if (typeof callback === 'function') {
                            callback();
                        }
                    });
                });
            }
        </script>


        <div class="container main-form">
            <div class="columns is-multiline">
                <div class="column is-12">
                    <h1 class="title">Create Job</h1>
                    <h2 class="subtitle">Select container image and configuration</h2>
                </div>
            </div>
            
            <!-- Image Selection -->
            <div class="form-section">
                <h3 class="section-title">Image Selection</h3>
                <div class="field">
                    <label class="label">Container Image</label>
                    <div class="control">
                        <div class="select is-fullwidth">
                            <select name="master_image"></select>
                        </div>
                    </div>
                </div>

                <!-- Image metadata display area -->
                <div id="image-metadata-container" style="display: none;">
                    <div id="image-metadata-content" class="content markdown-body"></div>
                </div>
            </div>
            
            <!-- Basic Information -->
            <div class="form-section">
                <h3 class="section-title">Basic</h3>
                <div class="columns">
                    <div class="column is-4 field">
                        <label class="label">Namespace</label>
                        <div class="control">
                            <input class="input" type="text" name="namespace" placeholder="Set automatically">
                        </div>
                    </div>
                    <div class="column is-8 field">
                        <label class="label">Job Name</label>
                        <div class="control">
                            <input class="input" type="text" name="job_name" value="job" placeholder="job">
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- GPU Selection -->
            <div class="form-section">
                <h3 class="section-title">GPU Configuration</h3>

                <div class="field">
                <div id="gpu-type-selection" class="field" style="display: none;">
                    <!-- <label class="label">Available GPU Types for Selection</label> -->
                    <div class="control">
                        <div id="gpu-options-container" class="buttons gpu-buttons-container"></div>
                        <input type="hidden" id="gpu-type-input" name="gpu_type" value="">
                        <input type="hidden" id="gpu-name-input" name="gpu_name" value="">
                    </div>
                </div>

                <!-- The regioin label -->
                <div class="control">
                    <button id="toggle-region-selection" class="button is-small mb-2 borderless-button" style="border: none !important;">
                        <span class="icon">
                            <i class="fas fa-chevron-right"></i>
                        </span>
                        <span>Regions</span>
                    </button>
                    <div id="region-options-container" class="buttons region-buttons-container" style="display: none;">
                    </div>
                    <input type="hidden" id="selected-region-input" name="selected_region" value="[]">
                    <script>
                        document.getElementById('toggle-region-selection').addEventListener('click', function() {
                            const container = document.getElementById('region-options-container');
                            const icon = this.querySelector('.icon i');
                            const text = this.querySelector('span:not(.icon)');
                            
                            if (container.style.display === 'none') {
                                container.style.display = 'flex';
                                icon.classList.remove('fa-chevron-right');
                                icon.classList.add('fa-chevron-down');
                                text.textContent = 'Regions';
                            } else {
                                container.style.display = 'none';
                                icon.classList.remove('fa-chevron-down');
                                icon.classList.add('fa-chevron-right');
                                text.textContent = 'Regions';
                            }
                        });
                    </script>
                </div>

                <!-- GPU and node number input -->
                <div id="gpu-node-section" class="field" style="display: none;">
                    <!-- <label class="label">GPU and Node Configuration</label> -->
                    <div class="control">
                        <div class="field is-horizontal">
                            <div class="field-body">
                                <div class="field">
                                    <label class="label">GPUs per Node: </label>
                                    <div class="control">
                                        <div class="select">
                                            <select id="num-gpu-per-node-select" name="num_gpu_per_node" onchange="updateNodeMaxCount()">
                                                <!-- <option value="0" selected>0 GPU</option> -->
                                                <option value="1" selected>1 GPU</option>
                                                <option value="2">2 GPUs</option>
                                                <option value="4">4 GPUs</option>
                                                <option value="8">8 GPUs</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                                <div class="field">
                                    <label class="label">Number of Nodes: </label>
                                    <div class="control">
                                        <input id="num-node-input" class="input" type="number" name="num_node" min="0" max="1" oninput="validateNodeInput(this)" defaultValue="0">
                                    </div>
                                </div>
                            </div>
                        </div>
                        <p id="gpu-limit-warning" class="help is-danger" style="display: none;">
                            The total number of GPUs exceeds the available limit.
                        </p>
                        <p id="node-limit-warning" class="help is-danger" style="display: none;">
                            Please enter a valid number of nodes between 0 and the maximum available.
                        </p>
                    </div>           

                    
                    <!-- Resource Allocation Preview -->
                    <div id="resource-allocation-preview" class="mt-4" style="display: none;">
                        <label class="label">Resource Allocation Preview</label>
                        <div class="box has-background-white-ter">
                            <div class="resource-preview-grid">
                                <div class="resource-item">
                                    <span class="icon-text">
                                        <span class="icon has-text-info">
                                            <i class="fas fa-microchip"></i>
                                        </span>
                                        <span class="has-text-weight-medium">
                                            GPU
                                            <span id="status-icons-container" class="status-icons-container" style="display: inline-block;">
                                                <span id="match-status-good" class="match-status good">
                                                    <i class="fas fa-check-circle" data-tooltip="Good"></i>
                                                </span>
                                                <span id="match-status-poor" class="match-status poor">
                                                    <i class="fas fa-exclamation-circle" data-tooltip="Below Requirements"></i>
                                                </span>
                                            </span>:
                                        </span>
                                    </span>
                                    <span id="preview-gpu-info" class="resource-value">-</span>
                                </div>
                                <div class="resource-item">
                                    <span class="icon-text">
                                        <span class="icon has-text-success">
                                            <i class="fas fa-cog"></i>
                                        </span>
                                        <span class="has-text-weight-medium">CPU:</span>
                                    </span>
                                    <span id="preview-cpu-info" class="resource-value">-</span>
                                </div>
                                <div class="resource-item">
                                    <span class="icon-text">
                                        <span class="icon has-text-warning">
                                            <i class="fas fa-memory"></i>
                                        </span>
                                        <span class="has-text-weight-medium">Memory:</span>
                                    </span>
                                    <span id="preview-memory-info" class="resource-value">-</span>
                                </div>
                                <div class="resource-item">
                                    <span class="icon-text">
                                        <span class="icon has-text-primary">
                                            <i class="fas fa-hdd"></i>
                                        </span>
                                        <span class="has-text-weight-medium">Storage:</span>
                                    </span>
                                    <span id="preview-storage-info" class="resource-value">100GB temporary storage</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Resource Matching Analysis section - same level as Resource Allocation Preview -->
                    <div id="resource-matching-analysis" class="mt-4" style="display: none;">
                        <label class="label">Resource Matching Analysis</label>
                        <div class="box has-background-white-ter">
                            <div class="resource-match-item">
                                <div class="resource-match-label">
                                    Current Model 
                                    <span id="model-name">Resource Match:</span>
                                    <span id="match-status" class="match-status good">Good</span>
                                </div>
                            </div>
                            
                            <div class="resource-match-item">
                                <div class="resource-match-label">Estimated Memory Usage:</div>
                                <div class="progress-bar-container">
                                    <div id="memory-usage-bar" class="progress-bar memory" style="width: 62.5%;"></div>
                                </div>
                                <div class="usage-info">
                                    <span id="memory-usage-text">~40GB/64GB</span>
                                    <span id="memory-usage-percent">62.5%</span>
                                </div>
                            </div>
                            
                            <div class="resource-match-item">
                                <div class="resource-match-label">Estimated GPU Utilisation:</div>
                                <div class="progress-bar-container">
                                    <div id="gpu-usage-bar" class="progress-bar gpu" style="width: 85%;"></div>
                                </div>
                                <div class="usage-info">
                                    <span></span>
                                    <span id="gpu-usage-percent">~85%</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Job Configuration -->
            <div class="form-section">
                <h3 class="section-title">Job Configuration</h3>
                
                <!-- Entry Command -->
                <div id="entrypoint-section" class="field">
                    <label class="label">Entry Command (Leaving empty will retain only the SSH connection.)</label>
                    <div class="control">
                        <input class="input" type="text" name="command" value="" placeholder="e.g.: /usr/sbin/sshd -D">
                    </div>
                </div>
                
                <!-- Exposed Ports -->
                <div class="field">
                    <label class="label">Exposed Ports</label>
                    <div class="control">
                        <input class="input exposed-port" type="text" placeholder="Comma-separated ports (e.g.: 22,80,8080)">
                    </div>
                </div>
                
                <!-- SSH Option - hidden, handled by code logic -->
                <div id="ssh-section" class="field" style="display: none;">
                    <label class="label">Enable SSH</label>
                    <div class="control">
                        <input type="checkbox" name="use_ssh" style="width: 20px; height: 20px;">
                    </div>
                </div>
            </div>
            
            <!-- Environment Variables -->
            <div id="env-vars-section" class="form-section">
                <h3 class="section-title">Environment Variables</h3>
                <div class="field env-var-container">
                    <div class="field is-grouped env-var">
                        <div class="control is-expanded">
                            <input class="input" type="text" name="env_name" placeholder="Variable name">
                        </div>
                        <div class="control is-expanded">
                            <input class="input" type="text" name="env_value" placeholder="Value">
                        </div>
                        <div class="control">
                            <button class="button is-primary" id="add_env_var">＋</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Submit Button -->
            <div class="field submit">
                <div class="control">
                    <button class="button primary is-medium" id="submit">Launch</button>
                </div>
            </div>
        </div>
    </section>
    
    <footer class="section footer">
        <div class="container">
            <div class="columns content">
                <div class="column items is-3">
                    <div class="item item-title">TACC Workflow</div>
                    <div class="item">Launch & Monitor AI Jobs</div>
                    <div class="item">Access Cloud Storage</div>
                    <div class="item">Manage Code & Scripts</div>
                </div>
                <div class="column items is-3">
                    <div class="item item-title">TACC Space</div>
                    <div class="item">Latest Public Images</div>
                    <div class="item">Public Dataset</div>
                    <div class="item">Discussion Groups</div>
                </div>
                <div class="column items is-3">
                    <div class="item item-title">Research</div>
                    <div class="item">AI-centric Networking</div>
                    <div class="item">Machine Learning Systems</div>
                    <div class="item">Cluster Resource Scheduling</div>
                </div>
                <div class="column items is-3">
                    <div class="item item-title">Company</div>
                    <div class="item">Our Team</div>
                    <div class="item">Careers</div>
                    <div class="item">HKUST iSING Lab</div>
                </div>
            </div>
            <div class="columns is-align-items-center">
                <div class="column is-narrow logo"><img src="assets/tacc-logo.png" /></div>
                <div class="column copyright is-narrow"><span class="text-colored">星畅</span> © 2020–2024</div>
            </div>
        </div>
    </footer>
</body>
</html>